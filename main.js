/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TikZAdvancedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/client/settings.ts
var DEFAULT_SETTINGS = {
  serverUrl: "http://localhost:3000",
  defaultOutputFormat: "svg",
  enableZoom: true,
  preferredEngine: "pdflatex",
  autoRefresh: true,
  cacheEnabled: true,
  cacheTTL: 60,
  showCacheIndicator: true,
  customPreamble: "",
  debugMode: false
};

// src/client/settingsTab.ts
var import_obsidian = require("obsidian");
var TikZSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Server Settings" });
    new import_obsidian.Setting(containerEl).setName("TikZ Server URL").setDesc("URL of the TikZ rendering server").addText((text) => {
      text.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Preferred LaTeX Engine").setDesc("Select the LaTeX engine to use for rendering").addDropdown((dropdown) => dropdown.addOption("pdflatex", "pdfLaTeX").addOption("lualatex", "LuaLaTeX").addOption("xelatex", "XeLaTeX").setValue(this.plugin.settings.preferredEngine).onChange(async (value) => {
      this.plugin.settings.preferredEngine = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Rendering Settings" });
    new import_obsidian.Setting(containerEl).setName("Default Output Format").setDesc("Choose the default output format for TikZ diagrams").addDropdown((dropdown) => dropdown.addOption("svg", "SVG").addOption("pdf", "PDF").setValue(this.plugin.settings.defaultOutputFormat).onChange(async (value) => {
      this.plugin.settings.defaultOutputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Zoom").setDesc("Allow zooming in and out of TikZ diagrams").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableZoom).onChange(async (value) => {
      this.plugin.settings.enableZoom = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Refresh").setDesc("Automatically refresh diagrams when code changes").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRefresh).onChange(async (value) => {
      this.plugin.settings.autoRefresh = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Cache Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Cache").setDesc("Cache rendered TikZ diagrams to improve performance").addToggle((toggle) => toggle.setValue(this.plugin.settings.cacheEnabled).onChange(async (value) => {
      this.plugin.settings.cacheEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Cache TTL (minutes)").setDesc("Time to live for cached diagrams in minutes").addText((text) => text.setPlaceholder("60").setValue(String(this.plugin.settings.cacheTTL)).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.cacheTTL = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Show Cache Indicator").setDesc("Show an indicator when a diagram is loaded from cache").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCacheIndicator).onChange(async (value) => {
      this.plugin.settings.showCacheIndicator = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Custom Preamble").setDesc("Additional LaTeX packages or commands. Note: The server already includes tikz, pgfplots, and common libraries.").addTextArea((text) => text.setPlaceholder("\\usepackage{tikz-cd}\n\\usepackage{tikz-3dplot}\n\\usetikzlibrary{decorations.pathmorphing}").setValue(this.plugin.settings.customPreamble).onChange(async (value) => {
      this.plugin.settings.customPreamble = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug mode for troubleshooting").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Test Server Connection").setDesc("Test the connection to the TikZ rendering server").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      containerEl.querySelectorAll(".connection-status").forEach((el) => el.remove());
      const statusEl = containerEl.createDiv("connection-status");
      statusEl.createEl("h4", { text: "Connection Status" });
      const statusTextEl = statusEl.createDiv("status-text");
      statusTextEl.createEl("span", { text: "Testing connection..." });
      try {
        const isConnected = await this.plugin.serverConnector.testConnection();
        statusTextEl.empty();
        if (isConnected) {
          statusTextEl.createEl("span", {
            text: "\u2705 Connected to server successfully",
            cls: "status-success"
          });
          try {
            const serverInfo = await this.plugin.serverConnector.getServerInfo();
            const infoEl = statusEl.createDiv("server-info");
            infoEl.createEl("div", {
              text: `Server Version: ${serverInfo.version}`
            });
            const enginesEl = infoEl.createEl("div", { text: "Available Engines:" });
            const enginesList = enginesEl.createEl("ul");
            for (const [engine, available] of Object.entries(serverInfo.engines)) {
              enginesList.createEl("li", {
                text: `${engine}: ${available ? "\u2705 Available" : "\u274C Not Available"}`
              });
            }
          } catch (infoError) {
          }
        } else {
          statusTextEl.createEl("span", {
            text: "\u274C Failed to connect to server",
            cls: "status-error"
          });
          const tipsEl = statusEl.createDiv("troubleshooting-tips");
          tipsEl.createEl("h5", { text: "Troubleshooting Tips:" });
          const tipsList = tipsEl.createEl("ul");
          tipsList.createEl("li", {
            text: "Make sure the server is running"
          });
          tipsList.createEl("li", {
            text: "Check that the server URL is correct"
          });
          tipsList.createEl("li", {
            text: "Try starting the server using the controls above"
          });
          tipsList.createEl("li", {
            text: "Check for firewall or network issues"
          });
        }
      } catch (error) {
        statusTextEl.empty();
        statusTextEl.createEl("span", {
          text: `\u274C Error: ${error.message}`,
          cls: "status-error"
        });
      }
    }));
  }
};

// src/client/tikzRenderer.ts
var TikZRenderer = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async render(source, containerEl, ctx) {
    const tikzContainer = containerEl.createDiv({ cls: "tikz-container" });
    const toolbar = tikzContainer.createDiv({ cls: "tikz-toolbar" });
    const formatSelector = toolbar.createDiv({ cls: "format-selector" });
    formatSelector.createSpan({ text: "Format: " });
    const svgButton = formatSelector.createEl("button", { text: "SVG" });
    const pdfButton = formatSelector.createEl("button", { text: "PDF" });
    if (this.plugin.settings.defaultOutputFormat === "svg") {
      svgButton.addClass("active");
    } else {
      pdfButton.addClass("active");
    }
    toolbar.createDiv({ cls: "spacer" });
    if (this.plugin.settings.enableZoom) {
      const zoomOutButton = toolbar.createEl("button", { text: "\u{1F50D}-" });
      const zoomResetButton = toolbar.createEl("button", { text: "100%" });
      const zoomInButton = toolbar.createEl("button", { text: "\u{1F50D}+" });
    }
    const refreshButton = toolbar.createEl("button", { text: "\u{1F504}" });
    const contentEl = tikzContainer.createDiv({ cls: "tikz-content" });
    if (this.plugin.settings.enableZoom) {
      contentEl.addClass("zoom-enabled");
    }
    const loadingEl = contentEl.createDiv({ cls: "tikz-loading" });
    loadingEl.createDiv({ cls: "tikz-loading-spinner" });
    const errorEl = tikzContainer.createDiv({ cls: "tikz-error tikz-hidden" });
    let cacheIndicator = null;
    if (this.plugin.settings.showCacheIndicator) {
      cacheIndicator = toolbar.createSpan({ cls: "tikz-cache-indicator" });
    }
    let renderResult = null;
    let fromCache = false;
    if (this.plugin.settings.cacheEnabled) {
      renderResult = this.plugin.cache.get(source, this.plugin.settings.defaultOutputFormat);
      if (renderResult) {
        fromCache = true;
      }
    }
    if (!renderResult) {
      try {
        renderResult = await this.plugin.serverConnector.renderTikZ(
          source,
          this.plugin.settings.defaultOutputFormat,
          this.plugin.settings.preferredEngine
        );
        if (this.plugin.settings.cacheEnabled && renderResult) {
          this.plugin.cache.set(source, renderResult);
        }
      } catch (error) {
        loadingEl.remove();
        errorEl.removeClass("tikz-hidden");
        errorEl.addClass("tikz-visible");
        errorEl.empty();
        if (error.errorInfo || error.errorHTML) {
          this.createStructuredErrorDisplay(errorEl, error);
        } else {
          errorEl.setText(`Error rendering TikZ: ${error.message}`);
        }
        console.error("TikZ rendering error:", error);
        return;
      }
    }
    loadingEl.remove();
    if (cacheIndicator && fromCache) {
      cacheIndicator.setText("(cached)");
    }
    if (renderResult) {
      if (renderResult.format === "svg") {
        const svgContainer = contentEl.createDiv();
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(renderResult.content, "image/svg+xml");
        const svgElement = svgDoc.documentElement;
        svgContainer.appendChild(document.importNode(svgElement, true));
      } else if (renderResult.format === "pdf") {
        const pdfEmbed = contentEl.createEl("embed", {
          attr: {
            type: "application/pdf",
            src: `data:application/pdf;base64,${renderResult.content}`,
            cls: "tikz-pdf-embed"
          }
        });
      }
    }
    svgButton.addEventListener("click", async () => {
      svgButton.addClass("active");
      pdfButton.removeClass("active");
      await this.updateFormat(source, contentEl, errorEl, cacheIndicator, "svg");
    });
    pdfButton.addEventListener("click", async () => {
      pdfButton.addClass("active");
      svgButton.removeClass("active");
      await this.updateFormat(source, contentEl, errorEl, cacheIndicator, "pdf");
    });
    refreshButton.addEventListener("click", async () => {
      await this.refreshRender(source, contentEl, errorEl, cacheIndicator);
    });
    if (this.plugin.settings.enableZoom) {
      let zoomLevel = 1;
      contentEl.addClass("tikz-content-zoom-1");
      contentEl.addEventListener("click", () => {
        if (zoomLevel === 1) {
          zoomLevel = 2;
          contentEl.removeClass("tikz-content-zoom-1");
          contentEl.addClass("tikz-content-zoom-2");
          contentEl.addClass("zoomed");
        } else {
          zoomLevel = 1;
          contentEl.removeClass("tikz-content-zoom-2");
          contentEl.addClass("tikz-content-zoom-1");
          contentEl.removeClass("zoomed");
        }
      });
    }
  }
  async updateFormat(source, contentEl, errorEl, cacheIndicator, format) {
    contentEl.empty();
    const loadingEl = contentEl.createDiv({ cls: "tikz-loading" });
    loadingEl.createDiv({ cls: "tikz-loading-spinner" });
    errorEl.addClass("tikz-hidden");
    errorEl.removeClass("tikz-visible");
    if (cacheIndicator) {
      cacheIndicator.setText("");
    }
    let renderResult = null;
    let fromCache = false;
    if (this.plugin.settings.cacheEnabled) {
      renderResult = this.plugin.cache.get(source, format);
      if (renderResult) {
        fromCache = true;
      }
    }
    if (!renderResult) {
      try {
        renderResult = await this.plugin.serverConnector.renderTikZ(
          source,
          format,
          this.plugin.settings.preferredEngine
        );
        if (this.plugin.settings.cacheEnabled && renderResult) {
          this.plugin.cache.set(source, renderResult);
        }
      } catch (error) {
        loadingEl.remove();
        errorEl.removeClass("tikz-hidden");
        errorEl.addClass("tikz-visible");
        if (this.plugin.settings.debugMode) {
          console.log("TikZ error object:", error);
          console.log("Error message:", error.message);
          console.log("Has errorHTML:", !!error.errorHTML);
          console.log("Has errorInfo:", !!error.errorInfo);
        }
        errorEl.empty();
        if (error.errorInfo || error.errorHTML) {
          this.createStructuredErrorDisplay(errorEl, error);
        } else {
          const errorContainer = errorEl.createDiv({ cls: "tikz-error-container" });
          const errorHeader = errorContainer.createDiv({ cls: "tikz-error-header error" });
          const errorIcon = errorHeader.createSpan({ cls: "tikz-error-icon" });
          const errorTitle = errorHeader.createSpan({
            cls: "tikz-error-title",
            text: "TikZ Error"
          });
          const errorMessage = errorContainer.createDiv({
            cls: "tikz-error-message specific-error",
            text: error.message || "Unknown error"
          });
          const noteEl = errorContainer.createDiv({
            cls: "tikz-error-note",
            text: "For more details, check the server logs or try running the TikZ code in a LaTeX editor."
          });
        }
        console.error("TikZ rendering error:", error);
        return;
      }
    }
    loadingEl.remove();
    if (cacheIndicator && fromCache) {
      cacheIndicator.setText("(cached)");
    }
    if (renderResult) {
      if (renderResult.format === "svg") {
        const svgContainer = contentEl.createDiv();
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(renderResult.content, "image/svg+xml");
        const svgElement = svgDoc.documentElement;
        svgContainer.appendChild(document.importNode(svgElement, true));
      } else if (renderResult.format === "pdf") {
        const pdfEmbed = contentEl.createEl("embed", {
          attr: {
            type: "application/pdf",
            src: `data:application/pdf;base64,${renderResult.content}`,
            cls: "tikz-pdf-embed"
          }
        });
      }
    }
  }
  async refreshRender(source, contentEl, errorEl, cacheIndicator) {
    contentEl.empty();
    const loadingEl = contentEl.createDiv({ cls: "tikz-loading" });
    loadingEl.createDiv({ cls: "tikz-loading-spinner" });
    errorEl.addClass("tikz-hidden");
    errorEl.removeClass("tikz-visible");
    if (cacheIndicator) {
      cacheIndicator.setText("");
    }
    if (this.plugin.settings.cacheEnabled) {
      this.plugin.cache.clear();
      console.log("Cache cleared for refresh");
    }
    try {
      const renderResult = await this.plugin.serverConnector.renderTikZ(
        source,
        this.plugin.settings.defaultOutputFormat,
        this.plugin.settings.preferredEngine
      );
      if (this.plugin.settings.cacheEnabled && renderResult) {
        this.plugin.cache.set(source, renderResult);
      }
      loadingEl.remove();
      if (renderResult) {
        if (renderResult.format === "svg") {
          const svgContainer = contentEl.createDiv();
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(renderResult.content, "image/svg+xml");
          const svgElement = svgDoc.documentElement;
          svgContainer.appendChild(document.importNode(svgElement, true));
        } else if (renderResult.format === "pdf") {
          const pdfEmbed = contentEl.createEl("embed", {
            attr: {
              type: "application/pdf",
              src: `data:application/pdf;base64,${renderResult.content}`,
              cls: "tikz-pdf-embed"
            }
          });
        }
      }
    } catch (error) {
      loadingEl.remove();
      errorEl.removeClass("tikz-hidden");
      errorEl.addClass("tikz-visible");
      if (this.plugin.settings.debugMode) {
        console.log("TikZ refresh error object:", error);
        console.log("Error message:", error.message);
        console.log("Has errorHTML:", !!error.errorHTML);
        console.log("Has errorInfo:", !!error.errorInfo);
      }
      errorEl.empty();
      if (error.errorInfo || error.errorHTML) {
        this.createStructuredErrorDisplay(errorEl, error);
      } else {
        const errorContainer = errorEl.createDiv({ cls: "tikz-error-container" });
        const errorHeader = errorContainer.createDiv({ cls: "tikz-error-header error" });
        const errorIcon = errorHeader.createSpan({ cls: "tikz-error-icon" });
        const errorTitle = errorHeader.createSpan({
          cls: "tikz-error-title",
          text: "TikZ Error"
        });
        const errorMessage = errorContainer.createDiv({
          cls: "tikz-error-message specific-error",
          text: error.message || "Unknown error"
        });
        const noteEl = errorContainer.createDiv({
          cls: "tikz-error-note",
          text: "For more details, check the server logs or try running the TikZ code in a LaTeX editor."
        });
      }
      console.error("TikZ refresh error:", error);
    }
  }
  createStructuredErrorDisplay(containerEl, error) {
    if (this.plugin.settings.debugMode) {
      console.log("Creating structured error display with:", error);
    }
    containerEl.empty();
    try {
      if (error.errorHTML) {
        const wrapper = containerEl.createDiv({ cls: "tikz-error-wrapper" });
        const parser = new DOMParser();
        const doc = parser.parseFromString(error.errorHTML, "text/html");
        const bodyContent = doc.body;
        if (bodyContent) {
          Array.from(bodyContent.childNodes).forEach((node) => {
            wrapper.appendChild(document.importNode(node, true));
          });
        }
        setTimeout(() => {
          const errorHeader2 = wrapper.querySelector(".tikz-error-header");
          const detailsSection = wrapper.querySelector(".tikz-error-details");
          const toggleButton2 = wrapper.querySelector(".tikz-error-toggle");
          if (errorHeader2 && detailsSection) {
            detailsSection.addClass("tikz-hidden");
            detailsSection.removeClass("tikz-visible");
            errorHeader2.addEventListener("click", () => {
              if (detailsSection.hasClass("tikz-hidden")) {
                detailsSection.removeClass("tikz-hidden");
                detailsSection.addClass("tikz-visible");
                if (toggleButton2)
                  toggleButton2.textContent = "\u25B2";
              } else {
                detailsSection.addClass("tikz-hidden");
                detailsSection.removeClass("tikz-visible");
                if (toggleButton2)
                  toggleButton2.textContent = "\u25BC";
              }
            });
          }
        }, 0);
        return;
      }
      const errorInfo = error.errorInfo || {
        message: error.message || "Unknown error",
        severity: "error",
        context: error.context || "",
        suggestion: ""
      };
      const errorContainer = containerEl.createDiv({ cls: "tikz-error-container" });
      const errorHeader = errorContainer.createDiv({ cls: "tikz-error-header" });
      errorHeader.createSpan({ cls: "tikz-error-icon" });
      errorHeader.createSpan({ cls: "tikz-error-title", text: "TikZ Error" });
      const toggleButton = errorHeader.createSpan({ cls: "tikz-error-toggle", text: "\u25BC" });
      const messageContainer = errorContainer.createDiv({
        cls: "tikz-error-message specific-error"
      });
      messageContainer.setText(error.message || errorInfo.message || "Unknown error");
      const detailsContainer = errorContainer.createDiv({ cls: "tikz-error-details tikz-hidden" });
      errorHeader.addEventListener("click", () => {
        if (detailsContainer.hasClass("tikz-hidden")) {
          detailsContainer.removeClass("tikz-hidden");
          detailsContainer.addClass("tikz-visible");
          toggleButton.setText("\u25B2");
        } else {
          detailsContainer.addClass("tikz-hidden");
          detailsContainer.removeClass("tikz-visible");
          toggleButton.setText("\u25BC");
        }
      });
      if (errorInfo.line) {
        detailsContainer.createDiv({
          cls: "tikz-error-line",
          text: `Line: ${errorInfo.line}`
        });
      }
      if (errorInfo.suggestion) {
        const suggestionEl = detailsContainer.createDiv({ cls: "tikz-error-suggestion" });
        suggestionEl.createEl("strong", { text: "Suggestion: " });
        suggestionEl.createSpan({ text: errorInfo.suggestion });
      }
      if (errorInfo.code) {
        const codeEl = detailsContainer.createDiv({ cls: "tikz-error-code" });
        codeEl.createEl("strong", { text: "Problematic code: " });
        const codeSpan = codeEl.createSpan();
        codeSpan.createEl("code", { text: errorInfo.code });
      }
      if (errorInfo.context) {
        const contextEl = detailsContainer.createDiv({ cls: "tikz-error-context" });
        contextEl.createEl("strong", { text: "Context: " });
        contextEl.createEl("pre", { text: errorInfo.context });
      }
      const noteEl = errorContainer.createDiv({ cls: "tikz-error-note" });
      noteEl.setText("For more details, check the server logs or try running the TikZ code in a LaTeX editor.");
      if (errorInfo.errorType) {
        const fixButtonContainer = detailsContainer.createDiv({ cls: "tikz-error-fix" });
        const fixButton = fixButtonContainer.createEl("button", {
          cls: "tikz-fix-button",
          text: "Get Help"
        });
        fixButton.addEventListener("click", () => {
          let helpUrl = "https://tikz.dev/";
          if (errorInfo.errorType === "UndefinedControlSequence") {
            helpUrl = "https://tikz.dev/errors#undefined-control-sequence";
          } else if (errorInfo.errorType === "MissingPackage") {
            helpUrl = "https://tikz.dev/errors#missing-package";
          } else if (errorInfo.errorType === "PreambleOnlyCommand") {
            helpUrl = "https://tikz.dev/errors#preamble-only-command";
          } else if (errorInfo.errorType === "MathModeError") {
            helpUrl = "https://tikz.dev/errors#math-mode-error";
          }
          window.open(helpUrl);
        });
      }
    } catch (err) {
      console.error("Error creating structured error display:", err);
      containerEl.setText(`Error rendering TikZ: ${error.message || "Unknown error"}`);
    }
  }
  cleanup() {
  }
};

// src/client/tikzCache.ts
var TikZCache = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.cache = /* @__PURE__ */ new Map();
  }
  get(source, format) {
    const cacheKey = this.getCacheKey(source, format);
    const entry = this.cache.get(cacheKey);
    if (!entry) {
      return null;
    }
    const now = Date.now();
    const ttlMs = this.plugin.settings.cacheTTL * 60 * 1e3;
    if (now - entry.timestamp > ttlMs) {
      this.cache.delete(cacheKey);
      return null;
    }
    return entry.result;
  }
  set(source, result) {
    const cacheKey = this.getCacheKey(source, result.format);
    this.cache.set(cacheKey, {
      result,
      timestamp: Date.now()
    });
  }
  clear() {
    this.cache.clear();
  }
  clearExpired() {
    const now = Date.now();
    const ttlMs = this.plugin.settings.cacheTTL * 60 * 1e3;
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > ttlMs) {
        this.cache.delete(key);
      }
    }
  }
  getCacheKey(source, format) {
    const engine = this.plugin.settings.preferredEngine;
    const preamble = this.plugin.settings.customPreamble;
    const libraryMatches = source.match(/\\usetikzlibrary\s*{([^}]*)}/g) || [];
    const librariesString = libraryMatches.join("");
    return `${this.hashString(source + format + engine + preamble + librariesString)}`;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }
};

// src/client/tikzServerConnector.ts
var import_obsidian2 = require("obsidian");
var TikZServerConnector = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/health`,
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      return response.status === 200;
    } catch (error) {
      if (this.plugin.settings.debugMode) {
        console.error("Error testing TikZ server connection:", error);
      }
      return false;
    }
  }
  async getServerInfo() {
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/health`,
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (response.status !== 200) {
        throw new Error(`Server returned status ${response.status}`);
      }
      return response.json;
    } catch (error) {
      if (this.plugin.settings.debugMode) {
        console.error("Error getting TikZ server info:", error);
      }
      throw error;
    }
  }
  async renderTikZ(source, format, engine) {
    if (this.plugin.settings.debugMode) {
      console.log("Rendering TikZ:", { source, format, engine });
    }
    try {
      const processedSource = this.preprocessTikZCode(source);
      const preamble = this.plugin.settings.customPreamble.trim() ? this.plugin.settings.customPreamble : void 0;
      const request = {
        tikzCode: processedSource,
        format,
        engine,
        preamble,
        source: "obsidian-plugin"
      };
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.plugin.settings.serverUrl}/render`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(request)
      });
      const result = response.json;
      if (result.error || result.success === false) {
        if (this.plugin.settings.debugMode) {
          console.log("Server returned error in response body:", result);
        }
        const error = new Error(result.error || "Unknown error");
        if (result.errorInfo) {
          error.errorInfo = result.errorInfo;
          if (this.plugin.settings.debugMode) {
            console.log("Error info from response:", result.errorInfo);
          }
        }
        if (result.errorHTML) {
          error.errorHTML = result.errorHTML;
          if (this.plugin.settings.debugMode) {
            console.log("Error HTML from response:", result.errorHTML ? "[HTML content available]" : void 0);
          }
        }
        if (result.errorType) {
          error.errorType = result.errorType;
        }
        if (result.severity) {
          error.severity = result.severity;
        }
        throw error;
      }
      return {
        content: result.content,
        format,
        width: result.width,
        height: result.height
      };
    } catch (error) {
      if (this.plugin.settings.debugMode) {
        console.error("Error rendering TikZ:", error);
      }
      throw error;
    }
  }
  preprocessTikZCode(source) {
    let processedSource = source;
    processedSource = processedSource.replace(/\\documentclass(\[[^\]]*\])?\{[^}]*\}/g, "");
    processedSource = processedSource.replace(/\\begin\s*\{\s*document\s*\}/g, "");
    processedSource = processedSource.replace(/\\end\s*\{\s*document\s*\}/g, "");
    processedSource = processedSource.replace(/\\usepackage(\[[^\]]*\])?\{[^}]*\}/g, "");
    processedSource = processedSource.replace(/\\pgfplotsset\s*\{[^}]*\}/g, "");
    processedSource = processedSource.trim();
    return processedSource;
  }
};

// src/client/serverManager.ts
var import_obsidian3 = require("obsidian");
var ServerManager = class {
  constructor(settings) {
    this.serverUrl = "";
    this.serverUrl = settings.serverUrl || "http://localhost:3000";
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url: `${this.serverUrl}/health`,
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      return response.status === 200;
    } catch (error) {
      console.error("TikZ Server connection error:", error);
      return false;
    }
  }
  getServerUrl() {
    return this.serverUrl;
  }
  setServerUrl(url) {
    this.serverUrl = url;
  }
  shutdown() {
  }
};

// src/main.ts
var TikZAdvancedPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.serverManager = null;
  }
  async onload() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    this.settings.save = async () => {
      await this.saveSettings();
    };
    this.cache = new TikZCache(this);
    this.serverConnector = new TikZServerConnector(this);
    this.renderer = new TikZRenderer(this);
    this.serverManager = new ServerManager(this.settings);
    this.registerMarkdownCodeBlockProcessor("tikz", this.processTikZBlock.bind(this));
    this.addSettingTab(new TikZSettingTab(this.app, this));
    this.checkServerConnection();
  }
  async processTikZBlock(source, el, ctx) {
    await this.renderer.render(source, el, ctx);
  }
  async checkServerConnection() {
    try {
      const isConnected = await this.serverConnector.testConnection();
      if (!isConnected) {
        new import_obsidian4.Notice("TikZ server connection failed. Please check your server settings.");
        if (this.settings.debugMode) {
          console.error("TikZ server connection failed");
        }
      }
    } catch (error) {
      new import_obsidian4.Notice(`TikZ server connection error: ${error.message}`);
      if (this.settings.debugMode) {
        console.error("TikZ server connection error:", error);
      }
    }
  }
  onunload() {
    if (this.serverManager) {
      this.serverManager.shutdown();
    }
    this.cache.clear();
    if (this.renderer) {
      this.renderer.cleanup();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
